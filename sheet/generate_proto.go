package sheet

import (
	"bytes"
	"fmt"
	"github.com/zero-yy/export-config/config"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
)

func generateProto(sheets []*Sheet) {
	protoOutputStr := ""
	protoOutputStr += getProtoHeader()
	for _, s := range sheets {
		protoOutputStr += s.getProtoCode()
	}
	saveProto(protoOutputStr)
}

const ShellToUse = "bash"

func shellOut(command string) (error, string, string) {
	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd := exec.Command(ShellToUse, "-c", command)
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	err := cmd.Run()
	return err, stdout.String(), stderr.String()
}

func callProtoC() {
	protocPath := config.C.ProtoCPath
	if len(protocPath) == 0 {
		protocPath = "protoc"
	}
	cmdParam := fmt.Sprintf("%s -I %s --go_out=%s --csharp_out=%s %s",
		protocPath,
		config.C.OutputProtoPath,
		config.C.OutputCodeGoPath,
		config.C.OutputCodeCSharpPath,
		ProtoFileName)

	fmt.Println(cmdParam)

	err, s1, s2 := shellOut(cmdParam)

	if err != nil {
		fmt.Println(err)
	}
	if len(s1) > 0 {
		fmt.Println(s1)
	}
	if len(s2) > 0 {
		fmt.Println(s2)
	}
}

func getProtoHeader() string {
	const kProtoFileHeadFmt = `// Code generated by export-config. DO NOT EDIT.

syntax = "proto3";
package %s;
option csharp_namespace = "%s";
option go_package = "%s";

`

	return fmt.Sprintf(kProtoFileHeadFmt,
		config.C.ProtoPackage,
		config.C.CSharpNamespace,
		config.C.GoPackage)
}

func saveProto(protoOutputStr string) {
	protoFn := path.Join(config.C.OutputProtoPath, ProtoFileName)
	if err := ioutil.WriteFile(protoFn, []byte(protoOutputStr), os.ModeExclusive|os.ModePerm); err != nil {
		panic(err.Error())
	}
}
